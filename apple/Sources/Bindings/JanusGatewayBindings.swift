// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

// swiftlint:disable all
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(JanusGatewayFFI)
import JanusGatewayFFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func empty() -> RustBuffer {
        RustBuffer(capacity: 0, len:0, data: nil)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_janus_gateway_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_janus_gateway_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        self.init(
            bytesNoCopy: rustBuffer.data!,
            count: Int(rustBuffer.len),
            deallocator: .none
        )
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous to the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        self.lock()
        defer { self.unlock() }
        return try f()
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_UNEXPECTED_ERROR: Int8 = 2
fileprivate let CALL_CANCELLED: Int8 = 3

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    let neverThrow: ((RustBuffer) throws -> Never)? = nil
    return try makeRustCall(callback, errorHandler: neverThrow)
}

private func rustCallWithError<T, E: Swift.Error>(
    _ errorHandler: @escaping (RustBuffer) throws -> E,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T, E: Swift.Error>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> E)?
) throws -> T {
    uniffiEnsureJanusGatewayInitialized()
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus<E: Swift.Error>(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> E)?
) throws {
    switch callStatus.code {
        case CALL_SUCCESS:
            return

        case CALL_ERROR:
            if let errorHandler = errorHandler {
                throw try errorHandler(callStatus.errorBuf)
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.unexpectedRustCallError
            }

        case CALL_UNEXPECTED_ERROR:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        case CALL_CANCELLED:
            fatalError("Cancellation not supported yet")

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

private func uniffiTraitInterfaceCall<T>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> ()
) {
    do {
        try writeReturn(makeCall())
    } catch let error {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}

private func uniffiTraitInterfaceCallWithError<T, E>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> (),
    lowerError: (E) -> RustBuffer
) {
    do {
        try writeReturn(makeCall())
    } catch let error as E {
        callStatus.pointee.code = CALL_ERROR
        callStatus.pointee.errorBuf = lowerError(error)
    } catch {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}
fileprivate final class UniffiHandleMap<T>: @unchecked Sendable {
    // All mutation happens with this lock held, which is why we implement @unchecked Sendable.
    private let lock = NSLock()
    private var map: [UInt64: T] = [:]
    private var currentHandle: UInt64 = 1

    func insert(obj: T) -> UInt64 {
        lock.withLock {
            let handle = currentHandle
            currentHandle += 1
            map[handle] = obj
            return handle
        }
    }

     func get(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map[handle] else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    @discardableResult
    func remove(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map.removeValue(forKey: handle) else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    var count: Int {
        get {
            map.count
        }
    }
}


// Public interface members begin here.


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt16: FfiConverterPrimitive {
    typealias FfiType = UInt16
    typealias SwiftType = UInt16

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt16 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterInt32: FfiConverterPrimitive {
    typealias FfiType = Int32
    typealias SwiftType = Int32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int32, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterBool : FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterData: FfiConverterRustBuffer {
    typealias SwiftType = Data

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Data {
        let len: Int32 = try readInt(&buf)
        return Data(try readBytes(&buf, count: Int(len)))
    }

    public static func write(_ value: Data, into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        writeBytes(&buf, value)
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDuration: FfiConverterRustBuffer {
    typealias SwiftType = TimeInterval

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TimeInterval {
        let seconds: UInt64 = try readInt(&buf)
        let nanoseconds: UInt32 = try readInt(&buf)
        return Double(seconds) + (Double(nanoseconds) / 1.0e9)
    }

    public static func write(_ value: TimeInterval, into buf: inout [UInt8]) {
        if value.rounded(.down) > Double(Int64.max) {
            fatalError("Duration overflow, exceeds max bounds supported by Uniffi")
        }

        if value < 0 {
            fatalError("Invalid duration, must be non-negative")
        }

        let seconds = UInt64(value)
        let nanoseconds = UInt32((value - Double(seconds)) * 1.0e9)
        writeInt(&buf, seconds)
        writeInt(&buf, nanoseconds)
    }
}




public protocol AudioBridgeHandleProtocol: AnyObject {
    
    func completeTrickle(timeout: TimeInterval) async throws 
    
    func createRoom(params: AudioBridgeCreateParams, timeout: TimeInterval) async throws  -> AudioBridgeRoomCreatedRsp
    
    func detach(timeout: TimeInterval) async throws 
    
    func fireAndForget(data: Data) async throws 
    
    func fireAndForgetWithJsep(data: Data, jsep: Jsep) async throws 
    
    func hangup(timeout: TimeInterval) async throws 
    
    func sendWaitonAck(data: Data, timeout: TimeInterval) async throws 
    
    func sendWaitonResult(data: Data, timeout: TimeInterval) async throws  -> Data
    
    func startEventLoop(cb: AudioBridgeHandleCallback) async 
    
    func trickleCandidates(candidates: [Candidate], timeout: TimeInterval) async throws 
    
    func trickleSingleCandidate(candidate: Candidate, timeout: TimeInterval) async throws 
    
}
open class AudioBridgeHandle: AudioBridgeHandleProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_janus_gateway_fn_clone_audiobridgehandle(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_janus_gateway_fn_free_audiobridgehandle(pointer, $0) }
    }

    

    
open func completeTrickle(timeout: TimeInterval)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_audiobridgehandle_complete_trickle(
                    self.uniffiClonePointer(),
                    FfiConverterDuration.lower(timeout)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_void,
            completeFunc: ffi_janus_gateway_rust_future_complete_void,
            freeFunc: ffi_janus_gateway_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError.lift
        )
}
    
open func createRoom(params: AudioBridgeCreateParams, timeout: TimeInterval)async throws  -> AudioBridgeRoomCreatedRsp  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_audiobridgehandle_create_room(
                    self.uniffiClonePointer(),
                    FfiConverterTypeAudioBridgeCreateParams_lower(params),FfiConverterDuration.lower(timeout)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_rust_buffer,
            completeFunc: ffi_janus_gateway_rust_future_complete_rust_buffer,
            freeFunc: ffi_janus_gateway_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeAudioBridgeRoomCreatedRsp_lift,
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError.lift
        )
}
    
open func detach(timeout: TimeInterval)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_audiobridgehandle_detach(
                    self.uniffiClonePointer(),
                    FfiConverterDuration.lower(timeout)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_void,
            completeFunc: ffi_janus_gateway_rust_future_complete_void,
            freeFunc: ffi_janus_gateway_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError.lift
        )
}
    
open func fireAndForget(data: Data)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_audiobridgehandle_fire_and_forget(
                    self.uniffiClonePointer(),
                    FfiConverterData.lower(data)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_void,
            completeFunc: ffi_janus_gateway_rust_future_complete_void,
            freeFunc: ffi_janus_gateway_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError.lift
        )
}
    
open func fireAndForgetWithJsep(data: Data, jsep: Jsep)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_audiobridgehandle_fire_and_forget_with_jsep(
                    self.uniffiClonePointer(),
                    FfiConverterData.lower(data),FfiConverterTypeJsep_lower(jsep)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_void,
            completeFunc: ffi_janus_gateway_rust_future_complete_void,
            freeFunc: ffi_janus_gateway_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError.lift
        )
}
    
open func hangup(timeout: TimeInterval)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_audiobridgehandle_hangup(
                    self.uniffiClonePointer(),
                    FfiConverterDuration.lower(timeout)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_void,
            completeFunc: ffi_janus_gateway_rust_future_complete_void,
            freeFunc: ffi_janus_gateway_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError.lift
        )
}
    
open func sendWaitonAck(data: Data, timeout: TimeInterval)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_audiobridgehandle_send_waiton_ack(
                    self.uniffiClonePointer(),
                    FfiConverterData.lower(data),FfiConverterDuration.lower(timeout)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_void,
            completeFunc: ffi_janus_gateway_rust_future_complete_void,
            freeFunc: ffi_janus_gateway_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError.lift
        )
}
    
open func sendWaitonResult(data: Data, timeout: TimeInterval)async throws  -> Data  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_audiobridgehandle_send_waiton_result(
                    self.uniffiClonePointer(),
                    FfiConverterData.lower(data),FfiConverterDuration.lower(timeout)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_rust_buffer,
            completeFunc: ffi_janus_gateway_rust_future_complete_rust_buffer,
            freeFunc: ffi_janus_gateway_rust_future_free_rust_buffer,
            liftFunc: FfiConverterData.lift,
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError.lift
        )
}
    
open func startEventLoop(cb: AudioBridgeHandleCallback)async   {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_audiobridgehandle_start_event_loop(
                    self.uniffiClonePointer(),
                    FfiConverterCallbackInterfaceAudioBridgeHandleCallback_lower(cb)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_void,
            completeFunc: ffi_janus_gateway_rust_future_complete_void,
            freeFunc: ffi_janus_gateway_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
open func trickleCandidates(candidates: [Candidate], timeout: TimeInterval)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_audiobridgehandle_trickle_candidates(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeCandidate.lower(candidates),FfiConverterDuration.lower(timeout)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_void,
            completeFunc: ffi_janus_gateway_rust_future_complete_void,
            freeFunc: ffi_janus_gateway_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError.lift
        )
}
    
open func trickleSingleCandidate(candidate: Candidate, timeout: TimeInterval)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_audiobridgehandle_trickle_single_candidate(
                    self.uniffiClonePointer(),
                    FfiConverterTypeCandidate_lower(candidate),FfiConverterDuration.lower(timeout)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_void,
            completeFunc: ffi_janus_gateway_rust_future_complete_void,
            freeFunc: ffi_janus_gateway_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError.lift
        )
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAudioBridgeHandle: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = AudioBridgeHandle

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> AudioBridgeHandle {
        return AudioBridgeHandle(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: AudioBridgeHandle) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AudioBridgeHandle {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: AudioBridgeHandle, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAudioBridgeHandle_lift(_ pointer: UnsafeMutableRawPointer) throws -> AudioBridgeHandle {
    return try FfiConverterTypeAudioBridgeHandle.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAudioBridgeHandle_lower(_ value: AudioBridgeHandle) -> UnsafeMutableRawPointer {
    return FfiConverterTypeAudioBridgeHandle.lower(value)
}






public protocol ConnectionProtocol: AnyObject {
    
    func createSession(kaInterval: UInt32, timeout: TimeInterval) async throws  -> Session
    
    func serverInfo(timeout: TimeInterval) async throws  -> ServerInfoRsp
    
}
open class Connection: ConnectionProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_janus_gateway_fn_clone_connection(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_janus_gateway_fn_free_connection(pointer, $0) }
    }

    

    
open func createSession(kaInterval: UInt32, timeout: TimeInterval)async throws  -> Session  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_connection_create_session(
                    self.uniffiClonePointer(),
                    FfiConverterUInt32.lower(kaInterval),FfiConverterDuration.lower(timeout)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_pointer,
            completeFunc: ffi_janus_gateway_rust_future_complete_pointer,
            freeFunc: ffi_janus_gateway_rust_future_free_pointer,
            liftFunc: FfiConverterTypeSession_lift,
            errorHandler: FfiConverterTypeJanusGatewaySessionError.lift
        )
}
    
open func serverInfo(timeout: TimeInterval)async throws  -> ServerInfoRsp  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_connection_server_info(
                    self.uniffiClonePointer(),
                    FfiConverterDuration.lower(timeout)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_rust_buffer,
            completeFunc: ffi_janus_gateway_rust_future_complete_rust_buffer,
            freeFunc: ffi_janus_gateway_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeServerInfoRsp_lift,
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError.lift
        )
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeConnection: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Connection

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Connection {
        return Connection(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Connection) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Connection {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Connection, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConnection_lift(_ pointer: UnsafeMutableRawPointer) throws -> Connection {
    return try FfiConverterTypeConnection.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConnection_lower(_ value: Connection) -> UnsafeMutableRawPointer {
    return FfiConverterTypeConnection.lower(value)
}






public protocol EchotestHandleProtocol: AnyObject {
    
    func completeTrickle(timeout: TimeInterval) async throws 
    
    func detach(timeout: TimeInterval) async throws 
    
    func fireAndForget(data: Data) async throws 
    
    func fireAndForgetWithJsep(data: Data, jsep: Jsep) async throws 
    
    func hangup(timeout: TimeInterval) async throws 
    
    func sendWaitonAck(data: Data, timeout: TimeInterval) async throws 
    
    func sendWaitonResult(data: Data, timeout: TimeInterval) async throws  -> Data
    
    func start(params: EchoTestStartParams) async throws 
    
    func startEventLoop(cb: EchotestHandleCallback) async 
    
    func startWithJsep(params: EchoTestStartParams, jsep: Jsep, timeout: TimeInterval) async throws 
    
    func trickleCandidates(candidates: [Candidate], timeout: TimeInterval) async throws 
    
    func trickleSingleCandidate(candidate: Candidate, timeout: TimeInterval) async throws 
    
}
open class EchotestHandle: EchotestHandleProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_janus_gateway_fn_clone_echotesthandle(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_janus_gateway_fn_free_echotesthandle(pointer, $0) }
    }

    

    
open func completeTrickle(timeout: TimeInterval)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_echotesthandle_complete_trickle(
                    self.uniffiClonePointer(),
                    FfiConverterDuration.lower(timeout)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_void,
            completeFunc: ffi_janus_gateway_rust_future_complete_void,
            freeFunc: ffi_janus_gateway_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError.lift
        )
}
    
open func detach(timeout: TimeInterval)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_echotesthandle_detach(
                    self.uniffiClonePointer(),
                    FfiConverterDuration.lower(timeout)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_void,
            completeFunc: ffi_janus_gateway_rust_future_complete_void,
            freeFunc: ffi_janus_gateway_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError.lift
        )
}
    
open func fireAndForget(data: Data)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_echotesthandle_fire_and_forget(
                    self.uniffiClonePointer(),
                    FfiConverterData.lower(data)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_void,
            completeFunc: ffi_janus_gateway_rust_future_complete_void,
            freeFunc: ffi_janus_gateway_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError.lift
        )
}
    
open func fireAndForgetWithJsep(data: Data, jsep: Jsep)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_echotesthandle_fire_and_forget_with_jsep(
                    self.uniffiClonePointer(),
                    FfiConverterData.lower(data),FfiConverterTypeJsep_lower(jsep)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_void,
            completeFunc: ffi_janus_gateway_rust_future_complete_void,
            freeFunc: ffi_janus_gateway_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError.lift
        )
}
    
open func hangup(timeout: TimeInterval)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_echotesthandle_hangup(
                    self.uniffiClonePointer(),
                    FfiConverterDuration.lower(timeout)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_void,
            completeFunc: ffi_janus_gateway_rust_future_complete_void,
            freeFunc: ffi_janus_gateway_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError.lift
        )
}
    
open func sendWaitonAck(data: Data, timeout: TimeInterval)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_echotesthandle_send_waiton_ack(
                    self.uniffiClonePointer(),
                    FfiConverterData.lower(data),FfiConverterDuration.lower(timeout)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_void,
            completeFunc: ffi_janus_gateway_rust_future_complete_void,
            freeFunc: ffi_janus_gateway_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError.lift
        )
}
    
open func sendWaitonResult(data: Data, timeout: TimeInterval)async throws  -> Data  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_echotesthandle_send_waiton_result(
                    self.uniffiClonePointer(),
                    FfiConverterData.lower(data),FfiConverterDuration.lower(timeout)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_rust_buffer,
            completeFunc: ffi_janus_gateway_rust_future_complete_rust_buffer,
            freeFunc: ffi_janus_gateway_rust_future_free_rust_buffer,
            liftFunc: FfiConverterData.lift,
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError.lift
        )
}
    
open func start(params: EchoTestStartParams)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_echotesthandle_start(
                    self.uniffiClonePointer(),
                    FfiConverterTypeEchoTestStartParams_lower(params)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_void,
            completeFunc: ffi_janus_gateway_rust_future_complete_void,
            freeFunc: ffi_janus_gateway_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError.lift
        )
}
    
open func startEventLoop(cb: EchotestHandleCallback)async   {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_echotesthandle_start_event_loop(
                    self.uniffiClonePointer(),
                    FfiConverterCallbackInterfaceEchotestHandleCallback_lower(cb)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_void,
            completeFunc: ffi_janus_gateway_rust_future_complete_void,
            freeFunc: ffi_janus_gateway_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
open func startWithJsep(params: EchoTestStartParams, jsep: Jsep, timeout: TimeInterval)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_echotesthandle_start_with_jsep(
                    self.uniffiClonePointer(),
                    FfiConverterTypeEchoTestStartParams_lower(params),FfiConverterTypeJsep_lower(jsep),FfiConverterDuration.lower(timeout)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_void,
            completeFunc: ffi_janus_gateway_rust_future_complete_void,
            freeFunc: ffi_janus_gateway_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError.lift
        )
}
    
open func trickleCandidates(candidates: [Candidate], timeout: TimeInterval)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_echotesthandle_trickle_candidates(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeCandidate.lower(candidates),FfiConverterDuration.lower(timeout)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_void,
            completeFunc: ffi_janus_gateway_rust_future_complete_void,
            freeFunc: ffi_janus_gateway_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError.lift
        )
}
    
open func trickleSingleCandidate(candidate: Candidate, timeout: TimeInterval)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_echotesthandle_trickle_single_candidate(
                    self.uniffiClonePointer(),
                    FfiConverterTypeCandidate_lower(candidate),FfiConverterDuration.lower(timeout)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_void,
            completeFunc: ffi_janus_gateway_rust_future_complete_void,
            freeFunc: ffi_janus_gateway_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError.lift
        )
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeEchotestHandle: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = EchotestHandle

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> EchotestHandle {
        return EchotestHandle(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: EchotestHandle) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EchotestHandle {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: EchotestHandle, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEchotestHandle_lift(_ pointer: UnsafeMutableRawPointer) throws -> EchotestHandle {
    return try FfiConverterTypeEchotestHandle.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEchotestHandle_lower(_ value: EchotestHandle) -> UnsafeMutableRawPointer {
    return FfiConverterTypeEchotestHandle.lower(value)
}






public protocol HandleProtocol: AnyObject {
    
    func completeTrickle(timeout: TimeInterval) async throws 
    
    func detach(timeout: TimeInterval) async throws 
    
    func fireAndForget(data: Data) async throws 
    
    func fireAndForgetWithJsep(data: Data, jsep: Jsep) async throws 
    
    func hangup(timeout: TimeInterval) async throws 
    
    func sendWaitonAck(data: Data, timeout: TimeInterval) async throws 
    
    func sendWaitonResult(data: Data, timeout: TimeInterval) async throws  -> Data
    
    func startEventLoop(cb: HandleCallback) async 
    
    func trickleCandidates(candidates: [Candidate], timeout: TimeInterval) async throws 
    
    func trickleSingleCandidate(candidate: Candidate, timeout: TimeInterval) async throws 
    
}
open class Handle: HandleProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_janus_gateway_fn_clone_handle(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_janus_gateway_fn_free_handle(pointer, $0) }
    }

    

    
open func completeTrickle(timeout: TimeInterval)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_handle_complete_trickle(
                    self.uniffiClonePointer(),
                    FfiConverterDuration.lower(timeout)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_void,
            completeFunc: ffi_janus_gateway_rust_future_complete_void,
            freeFunc: ffi_janus_gateway_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError.lift
        )
}
    
open func detach(timeout: TimeInterval)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_handle_detach(
                    self.uniffiClonePointer(),
                    FfiConverterDuration.lower(timeout)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_void,
            completeFunc: ffi_janus_gateway_rust_future_complete_void,
            freeFunc: ffi_janus_gateway_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError.lift
        )
}
    
open func fireAndForget(data: Data)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_handle_fire_and_forget(
                    self.uniffiClonePointer(),
                    FfiConverterData.lower(data)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_void,
            completeFunc: ffi_janus_gateway_rust_future_complete_void,
            freeFunc: ffi_janus_gateway_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError.lift
        )
}
    
open func fireAndForgetWithJsep(data: Data, jsep: Jsep)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_handle_fire_and_forget_with_jsep(
                    self.uniffiClonePointer(),
                    FfiConverterData.lower(data),FfiConverterTypeJsep_lower(jsep)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_void,
            completeFunc: ffi_janus_gateway_rust_future_complete_void,
            freeFunc: ffi_janus_gateway_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError.lift
        )
}
    
open func hangup(timeout: TimeInterval)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_handle_hangup(
                    self.uniffiClonePointer(),
                    FfiConverterDuration.lower(timeout)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_void,
            completeFunc: ffi_janus_gateway_rust_future_complete_void,
            freeFunc: ffi_janus_gateway_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError.lift
        )
}
    
open func sendWaitonAck(data: Data, timeout: TimeInterval)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_handle_send_waiton_ack(
                    self.uniffiClonePointer(),
                    FfiConverterData.lower(data),FfiConverterDuration.lower(timeout)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_void,
            completeFunc: ffi_janus_gateway_rust_future_complete_void,
            freeFunc: ffi_janus_gateway_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError.lift
        )
}
    
open func sendWaitonResult(data: Data, timeout: TimeInterval)async throws  -> Data  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_handle_send_waiton_result(
                    self.uniffiClonePointer(),
                    FfiConverterData.lower(data),FfiConverterDuration.lower(timeout)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_rust_buffer,
            completeFunc: ffi_janus_gateway_rust_future_complete_rust_buffer,
            freeFunc: ffi_janus_gateway_rust_future_free_rust_buffer,
            liftFunc: FfiConverterData.lift,
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError.lift
        )
}
    
open func startEventLoop(cb: HandleCallback)async   {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_handle_start_event_loop(
                    self.uniffiClonePointer(),
                    FfiConverterCallbackInterfaceHandleCallback_lower(cb)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_void,
            completeFunc: ffi_janus_gateway_rust_future_complete_void,
            freeFunc: ffi_janus_gateway_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
open func trickleCandidates(candidates: [Candidate], timeout: TimeInterval)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_handle_trickle_candidates(
                    self.uniffiClonePointer(),
                    FfiConverterSequenceTypeCandidate.lower(candidates),FfiConverterDuration.lower(timeout)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_void,
            completeFunc: ffi_janus_gateway_rust_future_complete_void,
            freeFunc: ffi_janus_gateway_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError.lift
        )
}
    
open func trickleSingleCandidate(candidate: Candidate, timeout: TimeInterval)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_handle_trickle_single_candidate(
                    self.uniffiClonePointer(),
                    FfiConverterTypeCandidate_lower(candidate),FfiConverterDuration.lower(timeout)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_void,
            completeFunc: ffi_janus_gateway_rust_future_complete_void,
            freeFunc: ffi_janus_gateway_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError.lift
        )
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeHandle: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Handle

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Handle {
        return Handle(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Handle) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Handle {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Handle, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHandle_lift(_ pointer: UnsafeMutableRawPointer) throws -> Handle {
    return try FfiConverterTypeHandle.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHandle_lower(_ value: Handle) -> UnsafeMutableRawPointer {
    return FfiConverterTypeHandle.lower(value)
}






public protocol SessionProtocol: AnyObject {
    
    func attach(pluginId: String, timeout: TimeInterval) async throws  -> Handle
    
    func attachAudioBridge(timeout: TimeInterval) async throws  -> AudioBridgeHandle
    
    func attachEchoTest(timeout: TimeInterval) async throws  -> EchotestHandle
    
    func destory(timeout: TimeInterval) async throws 
    
}
open class Session: SessionProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_janus_gateway_fn_clone_session(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_janus_gateway_fn_free_session(pointer, $0) }
    }

    

    
open func attach(pluginId: String, timeout: TimeInterval)async throws  -> Handle  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_session_attach(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(pluginId),FfiConverterDuration.lower(timeout)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_pointer,
            completeFunc: ffi_janus_gateway_rust_future_complete_pointer,
            freeFunc: ffi_janus_gateway_rust_future_free_pointer,
            liftFunc: FfiConverterTypeHandle_lift,
            errorHandler: FfiConverterTypeJanusGatewayHandleError.lift
        )
}
    
open func attachAudioBridge(timeout: TimeInterval)async throws  -> AudioBridgeHandle  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_session_attach_audio_bridge(
                    self.uniffiClonePointer(),
                    FfiConverterDuration.lower(timeout)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_pointer,
            completeFunc: ffi_janus_gateway_rust_future_complete_pointer,
            freeFunc: ffi_janus_gateway_rust_future_free_pointer,
            liftFunc: FfiConverterTypeAudioBridgeHandle_lift,
            errorHandler: FfiConverterTypeJanusGatewayHandleError.lift
        )
}
    
open func attachEchoTest(timeout: TimeInterval)async throws  -> EchotestHandle  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_session_attach_echo_test(
                    self.uniffiClonePointer(),
                    FfiConverterDuration.lower(timeout)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_pointer,
            completeFunc: ffi_janus_gateway_rust_future_complete_pointer,
            freeFunc: ffi_janus_gateway_rust_future_free_pointer,
            liftFunc: FfiConverterTypeEchotestHandle_lift,
            errorHandler: FfiConverterTypeJanusGatewayHandleError.lift
        )
}
    
open func destory(timeout: TimeInterval)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_method_session_destory(
                    self.uniffiClonePointer(),
                    FfiConverterDuration.lower(timeout)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_void,
            completeFunc: ffi_janus_gateway_rust_future_complete_void,
            freeFunc: ffi_janus_gateway_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeJanusGatewayCommunicationError.lift
        )
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSession: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Session

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Session {
        return Session(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Session) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Session {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Session, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSession_lift(_ pointer: UnsafeMutableRawPointer) throws -> Session {
    return try FfiConverterTypeSession.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSession_lower(_ value: Session) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSession.lower(value)
}




public struct AudioBridgeCreateParams {
    public let room: JanusId?
    public let permanent: Bool?
    public let description: String?
    public let secret: String?
    public let pin: String?
    public let isPrivate: Bool?
    public let allowed: [String]?
    public let samplingRate: UInt64?
    public let spatialAudio: Bool?
    public let audiolevelExt: Bool?
    public let audiolevelEvent: Bool?
    public let audioActivePackets: UInt64?
    public let defaultExpectedloss: UInt64?
    public let defaultBitrate: UInt64?
    public let record: Bool?
    public let recordFile: String?
    public let recordDir: String?
    public let mjrs: Bool?
    public let mjrsDir: String?
    public let allowRtpParticipants: Bool?
    public let groups: [String]?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(room: JanusId? = nil, permanent: Bool? = nil, description: String? = nil, secret: String? = nil, pin: String? = nil, isPrivate: Bool? = nil, allowed: [String]? = nil, samplingRate: UInt64? = nil, spatialAudio: Bool? = nil, audiolevelExt: Bool? = nil, audiolevelEvent: Bool? = nil, audioActivePackets: UInt64? = nil, defaultExpectedloss: UInt64? = nil, defaultBitrate: UInt64? = nil, record: Bool? = nil, recordFile: String? = nil, recordDir: String? = nil, mjrs: Bool? = nil, mjrsDir: String? = nil, allowRtpParticipants: Bool? = nil, groups: [String]? = nil) {
        self.room = room
        self.permanent = permanent
        self.description = description
        self.secret = secret
        self.pin = pin
        self.isPrivate = isPrivate
        self.allowed = allowed
        self.samplingRate = samplingRate
        self.spatialAudio = spatialAudio
        self.audiolevelExt = audiolevelExt
        self.audiolevelEvent = audiolevelEvent
        self.audioActivePackets = audioActivePackets
        self.defaultExpectedloss = defaultExpectedloss
        self.defaultBitrate = defaultBitrate
        self.record = record
        self.recordFile = recordFile
        self.recordDir = recordDir
        self.mjrs = mjrs
        self.mjrsDir = mjrsDir
        self.allowRtpParticipants = allowRtpParticipants
        self.groups = groups
    }
}

#if compiler(>=6)
extension AudioBridgeCreateParams: Sendable {}
#endif


extension AudioBridgeCreateParams: Equatable, Hashable {
    public static func ==(lhs: AudioBridgeCreateParams, rhs: AudioBridgeCreateParams) -> Bool {
        if lhs.room != rhs.room {
            return false
        }
        if lhs.permanent != rhs.permanent {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.secret != rhs.secret {
            return false
        }
        if lhs.pin != rhs.pin {
            return false
        }
        if lhs.isPrivate != rhs.isPrivate {
            return false
        }
        if lhs.allowed != rhs.allowed {
            return false
        }
        if lhs.samplingRate != rhs.samplingRate {
            return false
        }
        if lhs.spatialAudio != rhs.spatialAudio {
            return false
        }
        if lhs.audiolevelExt != rhs.audiolevelExt {
            return false
        }
        if lhs.audiolevelEvent != rhs.audiolevelEvent {
            return false
        }
        if lhs.audioActivePackets != rhs.audioActivePackets {
            return false
        }
        if lhs.defaultExpectedloss != rhs.defaultExpectedloss {
            return false
        }
        if lhs.defaultBitrate != rhs.defaultBitrate {
            return false
        }
        if lhs.record != rhs.record {
            return false
        }
        if lhs.recordFile != rhs.recordFile {
            return false
        }
        if lhs.recordDir != rhs.recordDir {
            return false
        }
        if lhs.mjrs != rhs.mjrs {
            return false
        }
        if lhs.mjrsDir != rhs.mjrsDir {
            return false
        }
        if lhs.allowRtpParticipants != rhs.allowRtpParticipants {
            return false
        }
        if lhs.groups != rhs.groups {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(room)
        hasher.combine(permanent)
        hasher.combine(description)
        hasher.combine(secret)
        hasher.combine(pin)
        hasher.combine(isPrivate)
        hasher.combine(allowed)
        hasher.combine(samplingRate)
        hasher.combine(spatialAudio)
        hasher.combine(audiolevelExt)
        hasher.combine(audiolevelEvent)
        hasher.combine(audioActivePackets)
        hasher.combine(defaultExpectedloss)
        hasher.combine(defaultBitrate)
        hasher.combine(record)
        hasher.combine(recordFile)
        hasher.combine(recordDir)
        hasher.combine(mjrs)
        hasher.combine(mjrsDir)
        hasher.combine(allowRtpParticipants)
        hasher.combine(groups)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAudioBridgeCreateParams: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AudioBridgeCreateParams {
        return
            try AudioBridgeCreateParams(
                room: FfiConverterOptionTypeJanusId.read(from: &buf), 
                permanent: FfiConverterOptionBool.read(from: &buf), 
                description: FfiConverterOptionString.read(from: &buf), 
                secret: FfiConverterOptionString.read(from: &buf), 
                pin: FfiConverterOptionString.read(from: &buf), 
                isPrivate: FfiConverterOptionBool.read(from: &buf), 
                allowed: FfiConverterOptionSequenceString.read(from: &buf), 
                samplingRate: FfiConverterOptionUInt64.read(from: &buf), 
                spatialAudio: FfiConverterOptionBool.read(from: &buf), 
                audiolevelExt: FfiConverterOptionBool.read(from: &buf), 
                audiolevelEvent: FfiConverterOptionBool.read(from: &buf), 
                audioActivePackets: FfiConverterOptionUInt64.read(from: &buf), 
                defaultExpectedloss: FfiConverterOptionUInt64.read(from: &buf), 
                defaultBitrate: FfiConverterOptionUInt64.read(from: &buf), 
                record: FfiConverterOptionBool.read(from: &buf), 
                recordFile: FfiConverterOptionString.read(from: &buf), 
                recordDir: FfiConverterOptionString.read(from: &buf), 
                mjrs: FfiConverterOptionBool.read(from: &buf), 
                mjrsDir: FfiConverterOptionString.read(from: &buf), 
                allowRtpParticipants: FfiConverterOptionBool.read(from: &buf), 
                groups: FfiConverterOptionSequenceString.read(from: &buf)
        )
    }

    public static func write(_ value: AudioBridgeCreateParams, into buf: inout [UInt8]) {
        FfiConverterOptionTypeJanusId.write(value.room, into: &buf)
        FfiConverterOptionBool.write(value.permanent, into: &buf)
        FfiConverterOptionString.write(value.description, into: &buf)
        FfiConverterOptionString.write(value.secret, into: &buf)
        FfiConverterOptionString.write(value.pin, into: &buf)
        FfiConverterOptionBool.write(value.isPrivate, into: &buf)
        FfiConverterOptionSequenceString.write(value.allowed, into: &buf)
        FfiConverterOptionUInt64.write(value.samplingRate, into: &buf)
        FfiConverterOptionBool.write(value.spatialAudio, into: &buf)
        FfiConverterOptionBool.write(value.audiolevelExt, into: &buf)
        FfiConverterOptionBool.write(value.audiolevelEvent, into: &buf)
        FfiConverterOptionUInt64.write(value.audioActivePackets, into: &buf)
        FfiConverterOptionUInt64.write(value.defaultExpectedloss, into: &buf)
        FfiConverterOptionUInt64.write(value.defaultBitrate, into: &buf)
        FfiConverterOptionBool.write(value.record, into: &buf)
        FfiConverterOptionString.write(value.recordFile, into: &buf)
        FfiConverterOptionString.write(value.recordDir, into: &buf)
        FfiConverterOptionBool.write(value.mjrs, into: &buf)
        FfiConverterOptionString.write(value.mjrsDir, into: &buf)
        FfiConverterOptionBool.write(value.allowRtpParticipants, into: &buf)
        FfiConverterOptionSequenceString.write(value.groups, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAudioBridgeCreateParams_lift(_ buf: RustBuffer) throws -> AudioBridgeCreateParams {
    return try FfiConverterTypeAudioBridgeCreateParams.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAudioBridgeCreateParams_lower(_ value: AudioBridgeCreateParams) -> RustBuffer {
    return FfiConverterTypeAudioBridgeCreateParams.lower(value)
}


public struct AudioBridgeRoomCreatedRsp {
    public let room: JanusId
    public let permanent: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(room: JanusId, permanent: Bool) {
        self.room = room
        self.permanent = permanent
    }
}

#if compiler(>=6)
extension AudioBridgeRoomCreatedRsp: Sendable {}
#endif


extension AudioBridgeRoomCreatedRsp: Equatable, Hashable {
    public static func ==(lhs: AudioBridgeRoomCreatedRsp, rhs: AudioBridgeRoomCreatedRsp) -> Bool {
        if lhs.room != rhs.room {
            return false
        }
        if lhs.permanent != rhs.permanent {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(room)
        hasher.combine(permanent)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAudioBridgeRoomCreatedRsp: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AudioBridgeRoomCreatedRsp {
        return
            try AudioBridgeRoomCreatedRsp(
                room: FfiConverterTypeJanusId.read(from: &buf), 
                permanent: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: AudioBridgeRoomCreatedRsp, into buf: inout [UInt8]) {
        FfiConverterTypeJanusId.write(value.room, into: &buf)
        FfiConverterBool.write(value.permanent, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAudioBridgeRoomCreatedRsp_lift(_ buf: RustBuffer) throws -> AudioBridgeRoomCreatedRsp {
    return try FfiConverterTypeAudioBridgeRoomCreatedRsp.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAudioBridgeRoomCreatedRsp_lower(_ value: AudioBridgeRoomCreatedRsp) -> RustBuffer {
    return FfiConverterTypeAudioBridgeRoomCreatedRsp.lower(value)
}


public struct Candidate {
    public let candidate: String
    public let sdpMid: String
    public let sdpMlineIndex: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(candidate: String, sdpMid: String, sdpMlineIndex: String) {
        self.candidate = candidate
        self.sdpMid = sdpMid
        self.sdpMlineIndex = sdpMlineIndex
    }
}

#if compiler(>=6)
extension Candidate: Sendable {}
#endif


extension Candidate: Equatable, Hashable {
    public static func ==(lhs: Candidate, rhs: Candidate) -> Bool {
        if lhs.candidate != rhs.candidate {
            return false
        }
        if lhs.sdpMid != rhs.sdpMid {
            return false
        }
        if lhs.sdpMlineIndex != rhs.sdpMlineIndex {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(candidate)
        hasher.combine(sdpMid)
        hasher.combine(sdpMlineIndex)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCandidate: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Candidate {
        return
            try Candidate(
                candidate: FfiConverterString.read(from: &buf), 
                sdpMid: FfiConverterString.read(from: &buf), 
                sdpMlineIndex: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: Candidate, into buf: inout [UInt8]) {
        FfiConverterString.write(value.candidate, into: &buf)
        FfiConverterString.write(value.sdpMid, into: &buf)
        FfiConverterString.write(value.sdpMlineIndex, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCandidate_lift(_ buf: RustBuffer) throws -> Candidate {
    return try FfiConverterTypeCandidate.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCandidate_lower(_ value: Candidate) -> RustBuffer {
    return FfiConverterTypeCandidate.lower(value)
}


public struct Config {
    public let url: String
    public let capacity: UInt16
    public let apisecret: String?
    public let serverRoot: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(url: String, capacity: UInt16, apisecret: String?, serverRoot: String = "janus") {
        self.url = url
        self.capacity = capacity
        self.apisecret = apisecret
        self.serverRoot = serverRoot
    }
}

#if compiler(>=6)
extension Config: Sendable {}
#endif


extension Config: Equatable, Hashable {
    public static func ==(lhs: Config, rhs: Config) -> Bool {
        if lhs.url != rhs.url {
            return false
        }
        if lhs.capacity != rhs.capacity {
            return false
        }
        if lhs.apisecret != rhs.apisecret {
            return false
        }
        if lhs.serverRoot != rhs.serverRoot {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(url)
        hasher.combine(capacity)
        hasher.combine(apisecret)
        hasher.combine(serverRoot)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeConfig: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Config {
        return
            try Config(
                url: FfiConverterString.read(from: &buf), 
                capacity: FfiConverterUInt16.read(from: &buf), 
                apisecret: FfiConverterOptionString.read(from: &buf), 
                serverRoot: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: Config, into buf: inout [UInt8]) {
        FfiConverterString.write(value.url, into: &buf)
        FfiConverterUInt16.write(value.capacity, into: &buf)
        FfiConverterOptionString.write(value.apisecret, into: &buf)
        FfiConverterString.write(value.serverRoot, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConfig_lift(_ buf: RustBuffer) throws -> Config {
    return try FfiConverterTypeConfig.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConfig_lower(_ value: Config) -> RustBuffer {
    return FfiConverterTypeConfig.lower(value)
}


public struct EchoTestStartParams {
    public let audio: Bool?
    public let video: Bool?
    public let bitrate: UInt32?
    public let record: Bool?
    public let filename: String?
    public let substream: UInt32?
    public let temporal: UInt32?
    public let fallback: UInt32?
    public let svc: Bool?
    public let spatialLayer: UInt32?
    public let temporalLayer: UInt32?
    public let audiocodec: String?
    public let videocodec: String?
    public let videoprofile: String?
    public let opusred: Bool?
    public let minDelay: Int32?
    public let maxDelay: Int32?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(audio: Bool? = nil, video: Bool? = nil, bitrate: UInt32? = nil, record: Bool? = nil, filename: String? = nil, substream: UInt32? = nil, temporal: UInt32? = nil, fallback: UInt32? = nil, svc: Bool? = nil, spatialLayer: UInt32? = nil, temporalLayer: UInt32? = nil, audiocodec: String? = nil, videocodec: String? = nil, videoprofile: String? = nil, opusred: Bool? = nil, minDelay: Int32? = nil, maxDelay: Int32? = nil) {
        self.audio = audio
        self.video = video
        self.bitrate = bitrate
        self.record = record
        self.filename = filename
        self.substream = substream
        self.temporal = temporal
        self.fallback = fallback
        self.svc = svc
        self.spatialLayer = spatialLayer
        self.temporalLayer = temporalLayer
        self.audiocodec = audiocodec
        self.videocodec = videocodec
        self.videoprofile = videoprofile
        self.opusred = opusred
        self.minDelay = minDelay
        self.maxDelay = maxDelay
    }
}

#if compiler(>=6)
extension EchoTestStartParams: Sendable {}
#endif


extension EchoTestStartParams: Equatable, Hashable {
    public static func ==(lhs: EchoTestStartParams, rhs: EchoTestStartParams) -> Bool {
        if lhs.audio != rhs.audio {
            return false
        }
        if lhs.video != rhs.video {
            return false
        }
        if lhs.bitrate != rhs.bitrate {
            return false
        }
        if lhs.record != rhs.record {
            return false
        }
        if lhs.filename != rhs.filename {
            return false
        }
        if lhs.substream != rhs.substream {
            return false
        }
        if lhs.temporal != rhs.temporal {
            return false
        }
        if lhs.fallback != rhs.fallback {
            return false
        }
        if lhs.svc != rhs.svc {
            return false
        }
        if lhs.spatialLayer != rhs.spatialLayer {
            return false
        }
        if lhs.temporalLayer != rhs.temporalLayer {
            return false
        }
        if lhs.audiocodec != rhs.audiocodec {
            return false
        }
        if lhs.videocodec != rhs.videocodec {
            return false
        }
        if lhs.videoprofile != rhs.videoprofile {
            return false
        }
        if lhs.opusred != rhs.opusred {
            return false
        }
        if lhs.minDelay != rhs.minDelay {
            return false
        }
        if lhs.maxDelay != rhs.maxDelay {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(audio)
        hasher.combine(video)
        hasher.combine(bitrate)
        hasher.combine(record)
        hasher.combine(filename)
        hasher.combine(substream)
        hasher.combine(temporal)
        hasher.combine(fallback)
        hasher.combine(svc)
        hasher.combine(spatialLayer)
        hasher.combine(temporalLayer)
        hasher.combine(audiocodec)
        hasher.combine(videocodec)
        hasher.combine(videoprofile)
        hasher.combine(opusred)
        hasher.combine(minDelay)
        hasher.combine(maxDelay)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeEchoTestStartParams: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EchoTestStartParams {
        return
            try EchoTestStartParams(
                audio: FfiConverterOptionBool.read(from: &buf), 
                video: FfiConverterOptionBool.read(from: &buf), 
                bitrate: FfiConverterOptionUInt32.read(from: &buf), 
                record: FfiConverterOptionBool.read(from: &buf), 
                filename: FfiConverterOptionString.read(from: &buf), 
                substream: FfiConverterOptionUInt32.read(from: &buf), 
                temporal: FfiConverterOptionUInt32.read(from: &buf), 
                fallback: FfiConverterOptionUInt32.read(from: &buf), 
                svc: FfiConverterOptionBool.read(from: &buf), 
                spatialLayer: FfiConverterOptionUInt32.read(from: &buf), 
                temporalLayer: FfiConverterOptionUInt32.read(from: &buf), 
                audiocodec: FfiConverterOptionString.read(from: &buf), 
                videocodec: FfiConverterOptionString.read(from: &buf), 
                videoprofile: FfiConverterOptionString.read(from: &buf), 
                opusred: FfiConverterOptionBool.read(from: &buf), 
                minDelay: FfiConverterOptionInt32.read(from: &buf), 
                maxDelay: FfiConverterOptionInt32.read(from: &buf)
        )
    }

    public static func write(_ value: EchoTestStartParams, into buf: inout [UInt8]) {
        FfiConverterOptionBool.write(value.audio, into: &buf)
        FfiConverterOptionBool.write(value.video, into: &buf)
        FfiConverterOptionUInt32.write(value.bitrate, into: &buf)
        FfiConverterOptionBool.write(value.record, into: &buf)
        FfiConverterOptionString.write(value.filename, into: &buf)
        FfiConverterOptionUInt32.write(value.substream, into: &buf)
        FfiConverterOptionUInt32.write(value.temporal, into: &buf)
        FfiConverterOptionUInt32.write(value.fallback, into: &buf)
        FfiConverterOptionBool.write(value.svc, into: &buf)
        FfiConverterOptionUInt32.write(value.spatialLayer, into: &buf)
        FfiConverterOptionUInt32.write(value.temporalLayer, into: &buf)
        FfiConverterOptionString.write(value.audiocodec, into: &buf)
        FfiConverterOptionString.write(value.videocodec, into: &buf)
        FfiConverterOptionString.write(value.videoprofile, into: &buf)
        FfiConverterOptionBool.write(value.opusred, into: &buf)
        FfiConverterOptionInt32.write(value.minDelay, into: &buf)
        FfiConverterOptionInt32.write(value.maxDelay, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEchoTestStartParams_lift(_ buf: RustBuffer) throws -> EchoTestStartParams {
    return try FfiConverterTypeEchoTestStartParams.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEchoTestStartParams_lower(_ value: EchoTestStartParams) -> RustBuffer {
    return FfiConverterTypeEchoTestStartParams.lower(value)
}


public struct Jsep {
    public let jsepType: JsepType
    public let trickle: Bool?
    public let sdp: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(jsepType: JsepType, trickle: Bool? = nil, sdp: String) {
        self.jsepType = jsepType
        self.trickle = trickle
        self.sdp = sdp
    }
}

#if compiler(>=6)
extension Jsep: Sendable {}
#endif


extension Jsep: Equatable, Hashable {
    public static func ==(lhs: Jsep, rhs: Jsep) -> Bool {
        if lhs.jsepType != rhs.jsepType {
            return false
        }
        if lhs.trickle != rhs.trickle {
            return false
        }
        if lhs.sdp != rhs.sdp {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(jsepType)
        hasher.combine(trickle)
        hasher.combine(sdp)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeJsep: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Jsep {
        return
            try Jsep(
                jsepType: FfiConverterTypeJsepType.read(from: &buf), 
                trickle: FfiConverterOptionBool.read(from: &buf), 
                sdp: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: Jsep, into buf: inout [UInt8]) {
        FfiConverterTypeJsepType.write(value.jsepType, into: &buf)
        FfiConverterOptionBool.write(value.trickle, into: &buf)
        FfiConverterString.write(value.sdp, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeJsep_lift(_ buf: RustBuffer) throws -> Jsep {
    return try FfiConverterTypeJsep.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeJsep_lower(_ value: Jsep) -> RustBuffer {
    return FfiConverterTypeJsep.lower(value)
}


public struct MetaData {
    public let name: String
    public let author: String
    public let description: String
    public let versionString: String
    public let version: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(name: String, author: String, description: String, versionString: String, version: UInt64) {
        self.name = name
        self.author = author
        self.description = description
        self.versionString = versionString
        self.version = version
    }
}

#if compiler(>=6)
extension MetaData: Sendable {}
#endif


extension MetaData: Equatable, Hashable {
    public static func ==(lhs: MetaData, rhs: MetaData) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.author != rhs.author {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.versionString != rhs.versionString {
            return false
        }
        if lhs.version != rhs.version {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(author)
        hasher.combine(description)
        hasher.combine(versionString)
        hasher.combine(version)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMetaData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MetaData {
        return
            try MetaData(
                name: FfiConverterString.read(from: &buf), 
                author: FfiConverterString.read(from: &buf), 
                description: FfiConverterString.read(from: &buf), 
                versionString: FfiConverterString.read(from: &buf), 
                version: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: MetaData, into buf: inout [UInt8]) {
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterString.write(value.author, into: &buf)
        FfiConverterString.write(value.description, into: &buf)
        FfiConverterString.write(value.versionString, into: &buf)
        FfiConverterUInt64.write(value.version, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMetaData_lift(_ buf: RustBuffer) throws -> MetaData {
    return try FfiConverterTypeMetaData.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMetaData_lower(_ value: MetaData) -> RustBuffer {
    return FfiConverterTypeMetaData.lower(value)
}


public struct ServerInfoRsp {
    public let name: String
    public let version: UInt64
    public let versionString: String
    public let author: String
    public let commitHash: String
    public let compileTime: String
    public let logToStdout: Bool
    public let logToFile: Bool
    public let dataChannels: Bool
    public let acceptingNewSessions: Bool
    public let sessionTimeout: UInt64
    public let reclaimSessionTimeout: UInt64
    public let candidatesTimeout: UInt64
    public let serverName: String
    public let localIp: String
    public let ipv6: Bool
    public let iceLite: Bool
    public let iceTcp: Bool
    public let iceNomination: String
    public let iceKeepaliveConncheck: Bool
    public let fullTrickle: Bool
    public let mdnsEnabled: Bool
    public let minNackQueue: UInt64
    public let twccPeriod: UInt64
    public let dtlsMtu: UInt64
    public let staticEventLoops: UInt64
    public let apiSecret: Bool
    public let authToken: Bool
    public let eventHandlers: Bool
    public let opaqueidInApi: Bool
    public let dependencies: [String: String]
    public let transports: [String: MetaData]
    public let plugins: [String: MetaData]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(name: String, version: UInt64, versionString: String, author: String, commitHash: String, compileTime: String, logToStdout: Bool, logToFile: Bool, dataChannels: Bool, acceptingNewSessions: Bool, sessionTimeout: UInt64, reclaimSessionTimeout: UInt64, candidatesTimeout: UInt64, serverName: String, localIp: String, ipv6: Bool, iceLite: Bool, iceTcp: Bool, iceNomination: String, iceKeepaliveConncheck: Bool, fullTrickle: Bool, mdnsEnabled: Bool, minNackQueue: UInt64, twccPeriod: UInt64, dtlsMtu: UInt64, staticEventLoops: UInt64, apiSecret: Bool, authToken: Bool, eventHandlers: Bool, opaqueidInApi: Bool, dependencies: [String: String], transports: [String: MetaData], plugins: [String: MetaData]) {
        self.name = name
        self.version = version
        self.versionString = versionString
        self.author = author
        self.commitHash = commitHash
        self.compileTime = compileTime
        self.logToStdout = logToStdout
        self.logToFile = logToFile
        self.dataChannels = dataChannels
        self.acceptingNewSessions = acceptingNewSessions
        self.sessionTimeout = sessionTimeout
        self.reclaimSessionTimeout = reclaimSessionTimeout
        self.candidatesTimeout = candidatesTimeout
        self.serverName = serverName
        self.localIp = localIp
        self.ipv6 = ipv6
        self.iceLite = iceLite
        self.iceTcp = iceTcp
        self.iceNomination = iceNomination
        self.iceKeepaliveConncheck = iceKeepaliveConncheck
        self.fullTrickle = fullTrickle
        self.mdnsEnabled = mdnsEnabled
        self.minNackQueue = minNackQueue
        self.twccPeriod = twccPeriod
        self.dtlsMtu = dtlsMtu
        self.staticEventLoops = staticEventLoops
        self.apiSecret = apiSecret
        self.authToken = authToken
        self.eventHandlers = eventHandlers
        self.opaqueidInApi = opaqueidInApi
        self.dependencies = dependencies
        self.transports = transports
        self.plugins = plugins
    }
}

#if compiler(>=6)
extension ServerInfoRsp: Sendable {}
#endif


extension ServerInfoRsp: Equatable, Hashable {
    public static func ==(lhs: ServerInfoRsp, rhs: ServerInfoRsp) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.version != rhs.version {
            return false
        }
        if lhs.versionString != rhs.versionString {
            return false
        }
        if lhs.author != rhs.author {
            return false
        }
        if lhs.commitHash != rhs.commitHash {
            return false
        }
        if lhs.compileTime != rhs.compileTime {
            return false
        }
        if lhs.logToStdout != rhs.logToStdout {
            return false
        }
        if lhs.logToFile != rhs.logToFile {
            return false
        }
        if lhs.dataChannels != rhs.dataChannels {
            return false
        }
        if lhs.acceptingNewSessions != rhs.acceptingNewSessions {
            return false
        }
        if lhs.sessionTimeout != rhs.sessionTimeout {
            return false
        }
        if lhs.reclaimSessionTimeout != rhs.reclaimSessionTimeout {
            return false
        }
        if lhs.candidatesTimeout != rhs.candidatesTimeout {
            return false
        }
        if lhs.serverName != rhs.serverName {
            return false
        }
        if lhs.localIp != rhs.localIp {
            return false
        }
        if lhs.ipv6 != rhs.ipv6 {
            return false
        }
        if lhs.iceLite != rhs.iceLite {
            return false
        }
        if lhs.iceTcp != rhs.iceTcp {
            return false
        }
        if lhs.iceNomination != rhs.iceNomination {
            return false
        }
        if lhs.iceKeepaliveConncheck != rhs.iceKeepaliveConncheck {
            return false
        }
        if lhs.fullTrickle != rhs.fullTrickle {
            return false
        }
        if lhs.mdnsEnabled != rhs.mdnsEnabled {
            return false
        }
        if lhs.minNackQueue != rhs.minNackQueue {
            return false
        }
        if lhs.twccPeriod != rhs.twccPeriod {
            return false
        }
        if lhs.dtlsMtu != rhs.dtlsMtu {
            return false
        }
        if lhs.staticEventLoops != rhs.staticEventLoops {
            return false
        }
        if lhs.apiSecret != rhs.apiSecret {
            return false
        }
        if lhs.authToken != rhs.authToken {
            return false
        }
        if lhs.eventHandlers != rhs.eventHandlers {
            return false
        }
        if lhs.opaqueidInApi != rhs.opaqueidInApi {
            return false
        }
        if lhs.dependencies != rhs.dependencies {
            return false
        }
        if lhs.transports != rhs.transports {
            return false
        }
        if lhs.plugins != rhs.plugins {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(version)
        hasher.combine(versionString)
        hasher.combine(author)
        hasher.combine(commitHash)
        hasher.combine(compileTime)
        hasher.combine(logToStdout)
        hasher.combine(logToFile)
        hasher.combine(dataChannels)
        hasher.combine(acceptingNewSessions)
        hasher.combine(sessionTimeout)
        hasher.combine(reclaimSessionTimeout)
        hasher.combine(candidatesTimeout)
        hasher.combine(serverName)
        hasher.combine(localIp)
        hasher.combine(ipv6)
        hasher.combine(iceLite)
        hasher.combine(iceTcp)
        hasher.combine(iceNomination)
        hasher.combine(iceKeepaliveConncheck)
        hasher.combine(fullTrickle)
        hasher.combine(mdnsEnabled)
        hasher.combine(minNackQueue)
        hasher.combine(twccPeriod)
        hasher.combine(dtlsMtu)
        hasher.combine(staticEventLoops)
        hasher.combine(apiSecret)
        hasher.combine(authToken)
        hasher.combine(eventHandlers)
        hasher.combine(opaqueidInApi)
        hasher.combine(dependencies)
        hasher.combine(transports)
        hasher.combine(plugins)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeServerInfoRsp: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ServerInfoRsp {
        return
            try ServerInfoRsp(
                name: FfiConverterString.read(from: &buf), 
                version: FfiConverterUInt64.read(from: &buf), 
                versionString: FfiConverterString.read(from: &buf), 
                author: FfiConverterString.read(from: &buf), 
                commitHash: FfiConverterString.read(from: &buf), 
                compileTime: FfiConverterString.read(from: &buf), 
                logToStdout: FfiConverterBool.read(from: &buf), 
                logToFile: FfiConverterBool.read(from: &buf), 
                dataChannels: FfiConverterBool.read(from: &buf), 
                acceptingNewSessions: FfiConverterBool.read(from: &buf), 
                sessionTimeout: FfiConverterUInt64.read(from: &buf), 
                reclaimSessionTimeout: FfiConverterUInt64.read(from: &buf), 
                candidatesTimeout: FfiConverterUInt64.read(from: &buf), 
                serverName: FfiConverterString.read(from: &buf), 
                localIp: FfiConverterString.read(from: &buf), 
                ipv6: FfiConverterBool.read(from: &buf), 
                iceLite: FfiConverterBool.read(from: &buf), 
                iceTcp: FfiConverterBool.read(from: &buf), 
                iceNomination: FfiConverterString.read(from: &buf), 
                iceKeepaliveConncheck: FfiConverterBool.read(from: &buf), 
                fullTrickle: FfiConverterBool.read(from: &buf), 
                mdnsEnabled: FfiConverterBool.read(from: &buf), 
                minNackQueue: FfiConverterUInt64.read(from: &buf), 
                twccPeriod: FfiConverterUInt64.read(from: &buf), 
                dtlsMtu: FfiConverterUInt64.read(from: &buf), 
                staticEventLoops: FfiConverterUInt64.read(from: &buf), 
                apiSecret: FfiConverterBool.read(from: &buf), 
                authToken: FfiConverterBool.read(from: &buf), 
                eventHandlers: FfiConverterBool.read(from: &buf), 
                opaqueidInApi: FfiConverterBool.read(from: &buf), 
                dependencies: FfiConverterDictionaryStringString.read(from: &buf), 
                transports: FfiConverterDictionaryStringTypeMetaData.read(from: &buf), 
                plugins: FfiConverterDictionaryStringTypeMetaData.read(from: &buf)
        )
    }

    public static func write(_ value: ServerInfoRsp, into buf: inout [UInt8]) {
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterUInt64.write(value.version, into: &buf)
        FfiConverterString.write(value.versionString, into: &buf)
        FfiConverterString.write(value.author, into: &buf)
        FfiConverterString.write(value.commitHash, into: &buf)
        FfiConverterString.write(value.compileTime, into: &buf)
        FfiConverterBool.write(value.logToStdout, into: &buf)
        FfiConverterBool.write(value.logToFile, into: &buf)
        FfiConverterBool.write(value.dataChannels, into: &buf)
        FfiConverterBool.write(value.acceptingNewSessions, into: &buf)
        FfiConverterUInt64.write(value.sessionTimeout, into: &buf)
        FfiConverterUInt64.write(value.reclaimSessionTimeout, into: &buf)
        FfiConverterUInt64.write(value.candidatesTimeout, into: &buf)
        FfiConverterString.write(value.serverName, into: &buf)
        FfiConverterString.write(value.localIp, into: &buf)
        FfiConverterBool.write(value.ipv6, into: &buf)
        FfiConverterBool.write(value.iceLite, into: &buf)
        FfiConverterBool.write(value.iceTcp, into: &buf)
        FfiConverterString.write(value.iceNomination, into: &buf)
        FfiConverterBool.write(value.iceKeepaliveConncheck, into: &buf)
        FfiConverterBool.write(value.fullTrickle, into: &buf)
        FfiConverterBool.write(value.mdnsEnabled, into: &buf)
        FfiConverterUInt64.write(value.minNackQueue, into: &buf)
        FfiConverterUInt64.write(value.twccPeriod, into: &buf)
        FfiConverterUInt64.write(value.dtlsMtu, into: &buf)
        FfiConverterUInt64.write(value.staticEventLoops, into: &buf)
        FfiConverterBool.write(value.apiSecret, into: &buf)
        FfiConverterBool.write(value.authToken, into: &buf)
        FfiConverterBool.write(value.eventHandlers, into: &buf)
        FfiConverterBool.write(value.opaqueidInApi, into: &buf)
        FfiConverterDictionaryStringString.write(value.dependencies, into: &buf)
        FfiConverterDictionaryStringTypeMetaData.write(value.transports, into: &buf)
        FfiConverterDictionaryStringTypeMetaData.write(value.plugins, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeServerInfoRsp_lift(_ buf: RustBuffer) throws -> ServerInfoRsp {
    return try FfiConverterTypeServerInfoRsp.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeServerInfoRsp_lower(_ value: ServerInfoRsp) -> RustBuffer {
    return FfiConverterTypeServerInfoRsp.lower(value)
}


public struct U63 {
    public let inner: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(inner: UInt64) {
        self.inner = inner
    }
}

#if compiler(>=6)
extension U63: Sendable {}
#endif


extension U63: Equatable, Hashable {
    public static func ==(lhs: U63, rhs: U63) -> Bool {
        if lhs.inner != rhs.inner {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(inner)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeU63: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> U63 {
        return
            try U63(
                inner: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: U63, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.inner, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeU63_lift(_ buf: RustBuffer) throws -> U63 {
    return try FfiConverterTypeU63.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeU63_lower(_ value: U63) -> RustBuffer {
    return FfiConverterTypeU63.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum GenericEvent {
    
    case detached
    /**
     * The PeerConnection was closed, either by Janus or by the user/application, and as such cannot be used anymore.
     */
    case hangup
    /**
     * Whether Janus is receiving (receiving: true/false) audio/video (type: "audio/video") on this PeerConnection.
     */
    case media
    case timeout
    /**
     * ICE and DTLS succeeded, and so Janus correctly established a PeerConnection with the user/application.
     */
    case webrtcUp
    /**
     * Whether Janus is reporting trouble sending/receiving (uplink: true/false) media on this PeerConnection.
     */
    case slowlink
    case trickle
}


#if compiler(>=6)
extension GenericEvent: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeGenericEvent: FfiConverterRustBuffer {
    typealias SwiftType = GenericEvent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GenericEvent {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .detached
        
        case 2: return .hangup
        
        case 3: return .media
        
        case 4: return .timeout
        
        case 5: return .webrtcUp
        
        case 6: return .slowlink
        
        case 7: return .trickle
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: GenericEvent, into buf: inout [UInt8]) {
        switch value {
        
        
        case .detached:
            writeInt(&buf, Int32(1))
        
        
        case .hangup:
            writeInt(&buf, Int32(2))
        
        
        case .media:
            writeInt(&buf, Int32(3))
        
        
        case .timeout:
            writeInt(&buf, Int32(4))
        
        
        case .webrtcUp:
            writeInt(&buf, Int32(5))
        
        
        case .slowlink:
            writeInt(&buf, Int32(6))
        
        
        case .trickle:
            writeInt(&buf, Int32(7))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGenericEvent_lift(_ buf: RustBuffer) throws -> GenericEvent {
    return try FfiConverterTypeGenericEvent.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGenericEvent_lower(_ value: GenericEvent) -> RustBuffer {
    return FfiConverterTypeGenericEvent.lower(value)
}


extension GenericEvent: Equatable, Hashable {}




public enum JanusGatewayCommunicationError {

    
    
    case Serialize(body: String
    )
    case SendFailure(reason: String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeJanusGatewayCommunicationError: FfiConverterRustBuffer {
    typealias SwiftType = JanusGatewayCommunicationError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> JanusGatewayCommunicationError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Serialize(
            body: try FfiConverterString.read(from: &buf)
            )
        case 2: return .SendFailure(
            reason: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: JanusGatewayCommunicationError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Serialize(body):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(body, into: &buf)
            
        
        case let .SendFailure(reason):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(reason, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeJanusGatewayCommunicationError_lift(_ buf: RustBuffer) throws -> JanusGatewayCommunicationError {
    return try FfiConverterTypeJanusGatewayCommunicationError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeJanusGatewayCommunicationError_lower(_ value: JanusGatewayCommunicationError) -> RustBuffer {
    return FfiConverterTypeJanusGatewayCommunicationError.lower(value)
}


extension JanusGatewayCommunicationError: Equatable, Hashable {}



extension JanusGatewayCommunicationError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}



public enum JanusGatewayConnectionError {

    
    
    case ConnectionFailure(reason: String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeJanusGatewayConnectionError: FfiConverterRustBuffer {
    typealias SwiftType = JanusGatewayConnectionError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> JanusGatewayConnectionError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .ConnectionFailure(
            reason: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: JanusGatewayConnectionError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .ConnectionFailure(reason):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(reason, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeJanusGatewayConnectionError_lift(_ buf: RustBuffer) throws -> JanusGatewayConnectionError {
    return try FfiConverterTypeJanusGatewayConnectionError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeJanusGatewayConnectionError_lower(_ value: JanusGatewayConnectionError) -> RustBuffer {
    return FfiConverterTypeJanusGatewayConnectionError.lower(value)
}


extension JanusGatewayConnectionError: Equatable, Hashable {}



extension JanusGatewayConnectionError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}



public enum JanusGatewayHandleError {

    
    
    case HandleCreationFailure(plugin: String, reason: String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeJanusGatewayHandleError: FfiConverterRustBuffer {
    typealias SwiftType = JanusGatewayHandleError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> JanusGatewayHandleError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .HandleCreationFailure(
            plugin: try FfiConverterString.read(from: &buf), 
            reason: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: JanusGatewayHandleError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .HandleCreationFailure(plugin,reason):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(plugin, into: &buf)
            FfiConverterString.write(reason, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeJanusGatewayHandleError_lift(_ buf: RustBuffer) throws -> JanusGatewayHandleError {
    return try FfiConverterTypeJanusGatewayHandleError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeJanusGatewayHandleError_lower(_ value: JanusGatewayHandleError) -> RustBuffer {
    return FfiConverterTypeJanusGatewayHandleError.lower(value)
}


extension JanusGatewayHandleError: Equatable, Hashable {}



extension JanusGatewayHandleError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}



public enum JanusGatewaySessionError {

    
    
    case SessionCreationFailure(reason: String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeJanusGatewaySessionError: FfiConverterRustBuffer {
    typealias SwiftType = JanusGatewaySessionError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> JanusGatewaySessionError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .SessionCreationFailure(
            reason: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: JanusGatewaySessionError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .SessionCreationFailure(reason):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(reason, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeJanusGatewaySessionError_lift(_ buf: RustBuffer) throws -> JanusGatewaySessionError {
    return try FfiConverterTypeJanusGatewaySessionError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeJanusGatewaySessionError_lower(_ value: JanusGatewaySessionError) -> RustBuffer {
    return FfiConverterTypeJanusGatewaySessionError.lower(value)
}


extension JanusGatewaySessionError: Equatable, Hashable {}



extension JanusGatewaySessionError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum JanusId {
    
    case string(String
    )
    case uint(U63
    )
}


#if compiler(>=6)
extension JanusId: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeJanusId: FfiConverterRustBuffer {
    typealias SwiftType = JanusId

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> JanusId {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .string(try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .uint(try FfiConverterTypeU63.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: JanusId, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .string(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .uint(v1):
            writeInt(&buf, Int32(2))
            FfiConverterTypeU63.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeJanusId_lift(_ buf: RustBuffer) throws -> JanusId {
    return try FfiConverterTypeJanusId.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeJanusId_lower(_ value: JanusId) -> RustBuffer {
    return FfiConverterTypeJanusId.lower(value)
}


extension JanusId: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum JsepType {
    
    case offer
    case answer
}


#if compiler(>=6)
extension JsepType: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeJsepType: FfiConverterRustBuffer {
    typealias SwiftType = JsepType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> JsepType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .offer
        
        case 2: return .answer
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: JsepType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .offer:
            writeInt(&buf, Int32(1))
        
        
        case .answer:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeJsepType_lift(_ buf: RustBuffer) throws -> JsepType {
    return try FfiConverterTypeJsepType.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeJsepType_lower(_ value: JsepType) -> RustBuffer {
    return FfiConverterTypeJsepType.lower(value)
}


extension JsepType: Equatable, Hashable {}






public protocol AudioBridgeHandleCallback: AnyObject {
    
    func onHandleEvent(event: GenericEvent) 
    
    func onAudioBridgeError(errorCode: UInt16, error: String) 
    
    func onOther(data: Data) 
    
}
// Magic number for the Rust proxy to call using the same mechanism as every other method,
// to free the callback once it's dropped by Rust.
private let IDX_CALLBACK_FREE: Int32 = 0
// Callback return codes
private let UNIFFI_CALLBACK_SUCCESS: Int32 = 0
private let UNIFFI_CALLBACK_ERROR: Int32 = 1
private let UNIFFI_CALLBACK_UNEXPECTED_ERROR: Int32 = 2

// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceAudioBridgeHandleCallback {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceAudioBridgeHandleCallback] = [UniffiVTableCallbackInterfaceAudioBridgeHandleCallback(
        onHandleEvent: { (
            uniffiHandle: UInt64,
            event: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceAudioBridgeHandleCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onHandleEvent(
                     event: try FfiConverterTypeGenericEvent_lift(event)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        onAudioBridgeError: { (
            uniffiHandle: UInt64,
            errorCode: UInt16,
            error: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceAudioBridgeHandleCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onAudioBridgeError(
                     errorCode: try FfiConverterUInt16.lift(errorCode),
                     error: try FfiConverterString.lift(error)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        onOther: { (
            uniffiHandle: UInt64,
            data: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceAudioBridgeHandleCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onOther(
                     data: try FfiConverterData.lift(data)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterCallbackInterfaceAudioBridgeHandleCallback.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface AudioBridgeHandleCallback: handle missing in uniffiFree")
            }
        }
    )]
}

private func uniffiCallbackInitAudioBridgeHandleCallback() {
    uniffi_janus_gateway_fn_init_callback_vtable_audiobridgehandlecallback(UniffiCallbackInterfaceAudioBridgeHandleCallback.vtable)
}

// FfiConverter protocol for callback interfaces
#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterCallbackInterfaceAudioBridgeHandleCallback {
    fileprivate static let handleMap = UniffiHandleMap<AudioBridgeHandleCallback>()
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
extension FfiConverterCallbackInterfaceAudioBridgeHandleCallback : FfiConverter {
    typealias SwiftType = AudioBridgeHandleCallback
    typealias FfiType = UInt64

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceAudioBridgeHandleCallback_lift(_ handle: UInt64) throws -> AudioBridgeHandleCallback {
    return try FfiConverterCallbackInterfaceAudioBridgeHandleCallback.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceAudioBridgeHandleCallback_lower(_ v: AudioBridgeHandleCallback) -> UInt64 {
    return FfiConverterCallbackInterfaceAudioBridgeHandleCallback.lower(v)
}




public protocol EchotestHandleCallback: AnyObject {
    
    func onResult(echotest: String, result: String) 
    
    func onResultWithJsep(echotest: String, result: String, jsep: Jsep) 
    
    func onEchoTestError(errorCode: UInt16, error: String) 
    
    func onHandleEvent(event: GenericEvent) 
    
    func onOther(data: Data) 
    
}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceEchotestHandleCallback {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceEchotestHandleCallback] = [UniffiVTableCallbackInterfaceEchotestHandleCallback(
        onResult: { (
            uniffiHandle: UInt64,
            echotest: RustBuffer,
            result: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceEchotestHandleCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onResult(
                     echotest: try FfiConverterString.lift(echotest),
                     result: try FfiConverterString.lift(result)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        onResultWithJsep: { (
            uniffiHandle: UInt64,
            echotest: RustBuffer,
            result: RustBuffer,
            jsep: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceEchotestHandleCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onResultWithJsep(
                     echotest: try FfiConverterString.lift(echotest),
                     result: try FfiConverterString.lift(result),
                     jsep: try FfiConverterTypeJsep_lift(jsep)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        onEchoTestError: { (
            uniffiHandle: UInt64,
            errorCode: UInt16,
            error: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceEchotestHandleCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onEchoTestError(
                     errorCode: try FfiConverterUInt16.lift(errorCode),
                     error: try FfiConverterString.lift(error)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        onHandleEvent: { (
            uniffiHandle: UInt64,
            event: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceEchotestHandleCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onHandleEvent(
                     event: try FfiConverterTypeGenericEvent_lift(event)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        onOther: { (
            uniffiHandle: UInt64,
            data: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceEchotestHandleCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onOther(
                     data: try FfiConverterData.lift(data)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterCallbackInterfaceEchotestHandleCallback.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface EchotestHandleCallback: handle missing in uniffiFree")
            }
        }
    )]
}

private func uniffiCallbackInitEchotestHandleCallback() {
    uniffi_janus_gateway_fn_init_callback_vtable_echotesthandlecallback(UniffiCallbackInterfaceEchotestHandleCallback.vtable)
}

// FfiConverter protocol for callback interfaces
#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterCallbackInterfaceEchotestHandleCallback {
    fileprivate static let handleMap = UniffiHandleMap<EchotestHandleCallback>()
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
extension FfiConverterCallbackInterfaceEchotestHandleCallback : FfiConverter {
    typealias SwiftType = EchotestHandleCallback
    typealias FfiType = UInt64

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceEchotestHandleCallback_lift(_ handle: UInt64) throws -> EchotestHandleCallback {
    return try FfiConverterCallbackInterfaceEchotestHandleCallback.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceEchotestHandleCallback_lower(_ v: EchotestHandleCallback) -> UInt64 {
    return FfiConverterCallbackInterfaceEchotestHandleCallback.lower(v)
}




public protocol HandleCallback: AnyObject {
    
    func onPluginEvent(event: Data) 
    
    func onHandleEvent(event: GenericEvent) 
    
}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceHandleCallback {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceHandleCallback] = [UniffiVTableCallbackInterfaceHandleCallback(
        onPluginEvent: { (
            uniffiHandle: UInt64,
            event: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceHandleCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onPluginEvent(
                     event: try FfiConverterData.lift(event)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        onHandleEvent: { (
            uniffiHandle: UInt64,
            event: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceHandleCallback.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onHandleEvent(
                     event: try FfiConverterTypeGenericEvent_lift(event)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterCallbackInterfaceHandleCallback.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface HandleCallback: handle missing in uniffiFree")
            }
        }
    )]
}

private func uniffiCallbackInitHandleCallback() {
    uniffi_janus_gateway_fn_init_callback_vtable_handlecallback(UniffiCallbackInterfaceHandleCallback.vtable)
}

// FfiConverter protocol for callback interfaces
#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterCallbackInterfaceHandleCallback {
    fileprivate static let handleMap = UniffiHandleMap<HandleCallback>()
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
extension FfiConverterCallbackInterfaceHandleCallback : FfiConverter {
    typealias SwiftType = HandleCallback
    typealias FfiType = UInt64

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceHandleCallback_lift(_ handle: UInt64) throws -> HandleCallback {
    return try FfiConverterCallbackInterfaceHandleCallback.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceHandleCallback_lower(_ v: HandleCallback) -> UInt64 {
    return FfiConverterCallbackInterfaceHandleCallback.lower(v)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionUInt32: FfiConverterRustBuffer {
    typealias SwiftType = UInt32?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt32.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt32.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionInt32: FfiConverterRustBuffer {
    typealias SwiftType = Int32?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterInt32.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterInt32.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionUInt64: FfiConverterRustBuffer {
    typealias SwiftType = UInt64?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt64.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt64.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionBool: FfiConverterRustBuffer {
    typealias SwiftType = Bool?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterBool.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterBool.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeJanusId: FfiConverterRustBuffer {
    typealias SwiftType = JanusId?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeJanusId.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeJanusId.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    public static func write(_ value: [String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String] {
        let len: Int32 = try readInt(&buf)
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterString.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeCandidate: FfiConverterRustBuffer {
    typealias SwiftType = [Candidate]

    public static func write(_ value: [Candidate], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeCandidate.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Candidate] {
        let len: Int32 = try readInt(&buf)
        var seq = [Candidate]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeCandidate.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDictionaryStringString: FfiConverterRustBuffer {
    public static func write(_ value: [String: String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterString.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: String] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: String]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterString.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDictionaryStringTypeMetaData: FfiConverterRustBuffer {
    public static func write(_ value: [String: MetaData], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterTypeMetaData.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: MetaData] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: MetaData]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterTypeMetaData.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}
private let UNIFFI_RUST_FUTURE_POLL_READY: Int8 = 0
private let UNIFFI_RUST_FUTURE_POLL_MAYBE_READY: Int8 = 1

fileprivate let uniffiContinuationHandleMap = UniffiHandleMap<UnsafeContinuation<Int8, Never>>()

fileprivate func uniffiRustCallAsync<F, T>(
    rustFutureFunc: () -> UInt64,
    pollFunc: (UInt64, @escaping UniffiRustFutureContinuationCallback, UInt64) -> (),
    completeFunc: (UInt64, UnsafeMutablePointer<RustCallStatus>) -> F,
    freeFunc: (UInt64) -> (),
    liftFunc: (F) throws -> T,
    errorHandler: ((RustBuffer) throws -> Swift.Error)?
) async throws -> T {
    // Make sure to call the ensure init function since future creation doesn't have a
    // RustCallStatus param, so doesn't use makeRustCall()
    uniffiEnsureJanusGatewayInitialized()
    let rustFuture = rustFutureFunc()
    defer {
        freeFunc(rustFuture)
    }
    var pollResult: Int8;
    repeat {
        pollResult = await withUnsafeContinuation {
            pollFunc(
                rustFuture,
                uniffiFutureContinuationCallback,
                uniffiContinuationHandleMap.insert(obj: $0)
            )
        }
    } while pollResult != UNIFFI_RUST_FUTURE_POLL_READY

    return try liftFunc(makeRustCall(
        { completeFunc(rustFuture, $0) },
        errorHandler: errorHandler
    ))
}

// Callback handlers for an async calls.  These are invoked by Rust when the future is ready.  They
// lift the return value or error and resume the suspended function.
fileprivate func uniffiFutureContinuationCallback(handle: UInt64, pollResult: Int8) {
    if let continuation = try? uniffiContinuationHandleMap.remove(handle: handle) {
        continuation.resume(returning: pollResult)
    } else {
        print("uniffiFutureContinuationCallback invalid handle")
    }
}
public func rawInitLogger()  {try! rustCall() {
    uniffi_janus_gateway_fn_func_raw_init_logger($0
    )
}
}
public func rawJanusConnect(config: Config)async throws  -> Connection  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_janus_gateway_fn_func_raw_janus_connect(FfiConverterTypeConfig_lower(config)
                )
            },
            pollFunc: ffi_janus_gateway_rust_future_poll_pointer,
            completeFunc: ffi_janus_gateway_rust_future_complete_pointer,
            freeFunc: ffi_janus_gateway_rust_future_free_pointer,
            liftFunc: FfiConverterTypeConnection_lift,
            errorHandler: FfiConverterTypeJanusGatewayConnectionError.lift
        )
}

private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}
// Use a global variable to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private let initializationResult: InitializationResult = {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 29
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_janus_gateway_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if (uniffi_janus_gateway_checksum_func_raw_init_logger() != 47317) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_func_raw_janus_connect() != 39620) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_audiobridgehandle_complete_trickle() != 64327) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_audiobridgehandle_create_room() != 56852) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_audiobridgehandle_detach() != 50253) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_audiobridgehandle_fire_and_forget() != 33585) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_audiobridgehandle_fire_and_forget_with_jsep() != 6039) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_audiobridgehandle_hangup() != 1409) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_audiobridgehandle_send_waiton_ack() != 44496) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_audiobridgehandle_send_waiton_result() != 47125) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_audiobridgehandle_start_event_loop() != 16772) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_audiobridgehandle_trickle_candidates() != 5622) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_audiobridgehandle_trickle_single_candidate() != 56691) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_connection_create_session() != 39238) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_connection_server_info() != 18308) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_echotesthandle_complete_trickle() != 25982) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_echotesthandle_detach() != 23878) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_echotesthandle_fire_and_forget() != 6820) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_echotesthandle_fire_and_forget_with_jsep() != 31372) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_echotesthandle_hangup() != 29523) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_echotesthandle_send_waiton_ack() != 51386) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_echotesthandle_send_waiton_result() != 15964) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_echotesthandle_start() != 6138) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_echotesthandle_start_event_loop() != 42772) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_echotesthandle_start_with_jsep() != 58592) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_echotesthandle_trickle_candidates() != 101) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_echotesthandle_trickle_single_candidate() != 3746) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_handle_complete_trickle() != 24960) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_handle_detach() != 1157) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_handle_fire_and_forget() != 43989) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_handle_fire_and_forget_with_jsep() != 28005) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_handle_hangup() != 23669) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_handle_send_waiton_ack() != 1198) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_handle_send_waiton_result() != 24292) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_handle_start_event_loop() != 781) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_handle_trickle_candidates() != 17041) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_handle_trickle_single_candidate() != 48289) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_session_attach() != 16557) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_session_attach_audio_bridge() != 17158) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_session_attach_echo_test() != 28942) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_session_destory() != 62073) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_audiobridgehandlecallback_on_handle_event() != 29862) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_audiobridgehandlecallback_on_audio_bridge_error() != 3044) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_audiobridgehandlecallback_on_other() != 24336) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_echotesthandlecallback_on_result() != 12927) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_echotesthandlecallback_on_result_with_jsep() != 57945) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_echotesthandlecallback_on_echo_test_error() != 12056) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_echotesthandlecallback_on_handle_event() != 49029) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_echotesthandlecallback_on_other() != 50197) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_handlecallback_on_plugin_event() != 21699) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_janus_gateway_checksum_method_handlecallback_on_handle_event() != 1626) {
        return InitializationResult.apiChecksumMismatch
    }

    uniffiCallbackInitAudioBridgeHandleCallback()
    uniffiCallbackInitEchotestHandleCallback()
    uniffiCallbackInitHandleCallback()
    return InitializationResult.ok
}()

// Make the ensure init function public so that other modules which have external type references to
// our types can call it.
public func uniffiEnsureJanusGatewayInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}

// swiftlint:enable all